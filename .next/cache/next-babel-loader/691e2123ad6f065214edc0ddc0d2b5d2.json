{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport _get from 'lodash-es/get';\nimport _isMatch from 'lodash-es/isMatch';\nimport _every from 'lodash-es/every';\nimport _extend from 'lodash-es/extend';\nimport { LIST_INIT, LIST_BEFORE_FETCH, LIST_AFTER_FETCH, LIST_ITEM_ADD, LIST_ITEM_UPDATE, LIST_DESTROY, LIST_TOGGLE_ITEM, LIST_TOGGLE_ALL, LIST_SET_LAYOUT } from '../actions/list';\nconst initialState = {\n  lists: {},\n  selectedIds: {}\n};\nexport default ((state = initialState, action) => {\n  switch (action.type) {\n    case LIST_INIT:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({\n            meta: {},\n            layoutName: null,\n            total: action.total || (action.items ? action.items.length : 0),\n            isFetched: !!action.items,\n            isLoading: false\n          }, action)\n        })\n      });\n\n    case LIST_BEFORE_FETCH:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, state.lists[action.listId], {}, action, {\n            isLoading: true\n          })\n        })\n      });\n\n    case LIST_AFTER_FETCH:\n      let items;\n      const list = state.lists[action.listId];\n\n      if (list && list.items && list.loadMore && list.page > 1) {\n        items = [].concat(list.items);\n        action.items.forEach((entry, i) => {\n          const index = (list.page - 1) * list.pageSize + i;\n          items[index] = entry;\n        });\n      } else {\n        items = [].concat(action.items);\n      }\n\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, list, {}, action, {\n            items,\n            isFetched: true,\n            isLoading: false\n          })\n        })\n      });\n\n    case LIST_ITEM_ADD:\n      if (state.lists[action.listId]) {\n        return _objectSpread({}, state, {\n          lists: _objectSpread({}, state.lists, {\n            [action.listId]: _objectSpread({}, state.lists[action.listId], {\n              items: action.prepend ? [].concat(action.item).concat(state.lists[action.listId].items) : [].concat(state.lists[action.listId].items).concat(action.item)\n            })\n          })\n        });\n      }\n\n      break;\n\n    case LIST_ITEM_UPDATE:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, state.lists[action.listId], {\n            items: state.lists[action.listId].items.map(item => {\n              if (_isMatch(item, action.condition)) {\n                item = _extend({}, item, action.item);\n              }\n\n              return item;\n            })\n          })\n        })\n      });\n\n    case LIST_DESTROY:\n      delete state.lists[action.listId];\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists)\n      });\n\n    case LIST_TOGGLE_ITEM:\n      const selectedIds = _get(state, ['selectedIds', action.listId]) || [];\n      const index = selectedIds.indexOf(action.itemId);\n\n      if (index === -1) {\n        selectedIds.push(action.itemId);\n      } else {\n        selectedIds.splice(index, 1);\n      }\n\n      return _objectSpread({}, state, {\n        selectedIds: _objectSpread({}, state.selectedIds, {\n          [action.listId]: [].concat(selectedIds)\n        })\n      });\n\n    case LIST_TOGGLE_ALL:\n      const list4 = state.lists[action.listId];\n\n      if (list4) {\n        const ids = list4.items.map(item => item[list4.primaryKey]) || [];\n\n        const isAll = state.selectedIds[action.listId] && _every(ids.map(id => state.selectedIds[action.listId].includes(id)));\n\n        return _objectSpread({}, state, {\n          selectedIds: _objectSpread({}, state.selectedIds, {\n            [action.listId]: isAll ? [] : ids\n          })\n        });\n      }\n\n      break;\n\n    case LIST_SET_LAYOUT:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, state.lists[action.listId], {\n            layoutName: action.layoutName\n          })\n        })\n      });\n  }\n\n  return state;\n});\nexport const getList = (state, listId) => _get(state, ['list', 'lists', listId]) || null;\nexport const getIds = (state, listId) => {\n  const list = getList(state, listId);\n  return list && list.items && list.items.map(item => item[list.primaryKey]) || [];\n};\nexport const getCheckedIds = (state, listId) => {\n  return _get(state, ['list', 'selectedIds', listId]) || [];\n};\nexport const isChecked = (state, listId, itemId) => getCheckedIds(state, listId).includes(itemId);\nexport const isCheckedAll = (state, listId) => {\n  const selectedIds = getCheckedIds(state, listId);\n  return selectedIds.length > 0 && _every(getIds(state, listId).map(id => selectedIds.includes(id)));\n};","map":{"version":3,"sources":["/usr/local/var/www/neutrino-web/node_modules/yii-steroids/reducers/list.js"],"names":["_get","_isMatch","_every","_extend","LIST_INIT","LIST_BEFORE_FETCH","LIST_AFTER_FETCH","LIST_ITEM_ADD","LIST_ITEM_UPDATE","LIST_DESTROY","LIST_TOGGLE_ITEM","LIST_TOGGLE_ALL","LIST_SET_LAYOUT","initialState","lists","selectedIds","state","action","type","listId","meta","layoutName","total","items","length","isFetched","isLoading","list","loadMore","page","concat","forEach","entry","i","index","pageSize","prepend","item","map","condition","indexOf","itemId","push","splice","list4","ids","primaryKey","isAll","id","includes","getList","getIds","getCheckedIds","isChecked","isCheckedAll"],"mappings":"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","sourcesContent":["import _get from 'lodash-es/get';\nimport _isMatch from 'lodash-es/isMatch';\nimport _every from 'lodash-es/every';\nimport _extend from 'lodash-es/extend';\n\nimport {\n    LIST_INIT,\n    LIST_BEFORE_FETCH,\n    LIST_AFTER_FETCH,\n    LIST_ITEM_ADD,\n    LIST_ITEM_UPDATE,\n    LIST_DESTROY,\n    LIST_TOGGLE_ITEM,\n    LIST_TOGGLE_ALL,\n    LIST_SET_LAYOUT,\n} from '../actions/list';\n\nconst initialState = {\n    lists: {},\n    selectedIds: {},\n};\n\nexport default (state = initialState, action) => {\n    switch (action.type) {\n        case LIST_INIT:\n            return {\n                ...state,\n                lists: {\n                    ...state.lists,\n                    [action.listId]: {\n                        meta: {},\n                        layoutName: null,\n                        total: action.total || (action.items ? action.items.length : 0),\n                        isFetched: !!action.items,\n                        isLoading: false,\n                        ...action,\n                    },\n                },\n            };\n\n        case LIST_BEFORE_FETCH:\n            return {\n                ...state,\n                lists: {\n                    ...state.lists,\n                    [action.listId]: {\n                        ...state.lists[action.listId],\n                        ...action,\n                        isLoading: true,\n                    }\n                }\n            };\n\n        case LIST_AFTER_FETCH:\n            let items;\n            const list = state.lists[action.listId];\n\n            if (list && list.items && list.loadMore && list.page > 1) {\n                items = [].concat(list.items);\n                action.items.forEach((entry, i) => {\n                    const index = ((list.page - 1) * list.pageSize) + i;\n                    items[index] = entry;\n                });\n            } else {\n                items = [].concat(action.items);\n            }\n\n            return {\n                ...state,\n                lists: {\n                    ...state.lists,\n                    [action.listId]: {\n                        ...list,\n                        ...action,\n                        items,\n                        isFetched: true,\n                        isLoading: false,\n                    }\n                }\n            };\n\n        case LIST_ITEM_ADD:\n            if (state.lists[action.listId]) {\n                return {\n                    ...state,\n                    lists: {\n                        ...state.lists,\n                        [action.listId]: {\n                            ...state.lists[action.listId],\n                            items: action.prepend\n                                ? [].concat(action.item).concat(state.lists[action.listId].items)\n                                : [].concat(state.lists[action.listId].items).concat(action.item),\n                        }\n                    }\n                };\n            }\n            break;\n\n        case LIST_ITEM_UPDATE:\n            return {\n                ...state,\n                lists: {\n                    ...state.lists,\n                    [action.listId]: {\n                        ...state.lists[action.listId],\n                        items: state.lists[action.listId].items.map(item => {\n                            if (_isMatch(item, action.condition)) {\n                                item = _extend({}, item, action.item);\n                            }\n                            return item;\n                        }),\n                    }\n                }\n            };\n\n        case LIST_DESTROY:\n            delete state.lists[action.listId];\n            return {\n                ...state,\n                lists: {\n                    ...state.lists,\n                }\n            };\n\n        case LIST_TOGGLE_ITEM:\n            const selectedIds = _get(state, ['selectedIds', action.listId]) || [];\n            const index = selectedIds.indexOf(action.itemId);\n            if (index === -1) {\n                selectedIds.push(action.itemId);\n            } else {\n                selectedIds.splice(index, 1);\n            }\n            return {\n                ...state,\n                selectedIds: {\n                    ...state.selectedIds,\n                    [action.listId]: [].concat(selectedIds),\n                },\n            };\n\n        case LIST_TOGGLE_ALL:\n            const list4 = state.lists[action.listId];\n            if (list4) {\n                const ids = list4.items.map(item => item[list4.primaryKey]) || [];\n                const isAll = state.selectedIds[action.listId] && _every(ids.map(id => state.selectedIds[action.listId].includes(id)));\n                return {\n                    ...state,\n                    selectedIds: {\n                        ...state.selectedIds,\n                        [action.listId]: isAll ? [] : ids,\n                    },\n                };\n            }\n            break;\n\n        case LIST_SET_LAYOUT:\n            return {\n                ...state,\n                lists: {\n                    ...state.lists,\n                    [action.listId]: {\n                        ...state.lists[action.listId],\n                        layoutName: action.layoutName,\n                    }\n                }\n            };\n    }\n\n    return state;\n};\n\nexport const getList = (state, listId) => _get(state, ['list', 'lists', listId]) || null;\nexport const getIds = (state, listId) => {\n    const list = getList(state, listId);\n    return list && list.items && list.items.map(item => item[list.primaryKey]) || [];\n};\nexport const getCheckedIds = (state, listId) => {\n    return _get(state, ['list', 'selectedIds', listId]) || [];\n};\nexport const isChecked = (state, listId, itemId) => getCheckedIds(state, listId).includes(itemId);\nexport const isCheckedAll = (state, listId) => {\n    const selectedIds = getCheckedIds(state, listId);\n    return selectedIds.length > 0 && _every(getIds(state, listId).map(id => selectedIds.includes(id)));\n};\n"]},"metadata":{},"sourceType":"module"}