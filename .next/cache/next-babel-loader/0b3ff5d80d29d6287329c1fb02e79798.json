{"ast":null,"code":"import _Number$isInteger from \"@babel/runtime-corejs2/core-js/number/is-integer\";\nimport _get from 'lodash/get';\nimport _isEqual from 'lodash/isEqual';\nimport { setUser } from 'yii-steroids/actions/auth';\nimport apiHoc from './dal/apiHoc';\nimport { clientStorage } from 'components';\nimport BalanceController from '../contractControllers/BalanceController';\nimport Keeper from './dal/Keeper';\nimport axios from 'axios';\nimport ContractEnum from '../enums/ContractEnum';\nimport UserRole from 'enums/UserRole';\nimport OrderTypeEnum from 'enums/OrderTypeEnum';\nexport const STORAGE_AUTH_KEY = 'isAuth';\nexport default class DalComponent {\n  constructor() {\n    this.network = null;\n    this.nodeUrl = null;\n    this.assets = null;\n    this.contracts = null;\n    this.hoc = apiHoc;\n    this.balance = new BalanceController({\n      dalRef: this\n    });\n    this.balance.onUpdate = this.login.bind(this);\n    this.keeper = new Keeper(this);\n    this.keeper.onUpdate = this.login.bind(this);\n\n    if (false && process.env.NODE_ENV !== 'production') {\n      window.dal = this;\n    }\n  }\n  /**\n   * Auth current user and return it data\n   * @returns {Promise}\n   */\n\n\n  async login() {\n    // Start keeper listener, fetch balances\n    const account = await this.keeper.getAccount();\n    await this.keeper.start();\n    await this.balance.start(account.address); // Keeper user\n\n    const user = account ? {\n      role: UserRole.REGISTERED,\n      address: account.address,\n      network: account.network,\n      balances: this.balance.getBalances()\n    } : null; // Mark logged\n\n    if (account && !this.isLogged()) {\n      clientStorage.set(STORAGE_AUTH_KEY, '1');\n    } // Update redux store\n\n\n    const store = require('components').store;\n\n    const storeUser = store.getState().auth.user || null;\n\n    if (!_isEqual(storeUser, user)) {\n      store.dispatch(setUser(user));\n    }\n\n    return user;\n  }\n  /**\n   * Check is logged flag\n   * @returns {boolean}\n   */\n\n\n  isLogged() {\n    return clientStorage.get(STORAGE_AUTH_KEY) === '1';\n  }\n  /**\n   * Logout user\n   * @returns {Promise<void>}\n   */\n\n\n  async logout() {\n    require('components').store.dispatch(setUser(null));\n\n    clientStorage.remove(STORAGE_AUTH_KEY);\n    this.keeper.stop();\n    this.balance.stop();\n  }\n\n  async swapWavesToNeutrino(pairName, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'swapWavesToNeutrino', [], 'WAVES', amount);\n  }\n\n  async swapNeutrinoToWaves(pairName, paymentCurrency, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'swapNeutrinoToWaves', [], this.assets[paymentCurrency], amount);\n  }\n\n  async withdraw(pairName, address, index) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'withdraw', [address, index], 'WAVES', 0);\n  }\n\n  async setBondOrder(pairName, price, paymentCurrency, bondsAmount) {\n    if (price <= 0 || price >= 1) {\n      return;\n    }\n\n    price = Math.round(price * 100) / 100;\n    const contractPrice = price * 100;\n\n    let position = _get((await axios.get(`/api/v1/bonds/${pairName}/position`, {\n      params: {\n        price: contractPrice\n      }\n    })), 'data.position');\n\n    if (price > 0 && bondsAmount > 0 && _Number$isInteger(position)) {\n      await this.keeper.sendTransaction(pairName, ContractEnum.AUCTION, 'addBuyBondOrder', [contractPrice, position], this.assets[paymentCurrency], bondsAmount * price);\n    }\n  }\n\n  async setLiquidateOrder(pairName, paymentCurrency, total) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.LIQUIDATION, 'addLiquidationOrder', [], this.assets[paymentCurrency], total);\n  }\n\n  async cancelOrder(pairName, type, hash) {\n    switch (type) {\n      case OrderTypeEnum.BUY:\n        await this.keeper.sendTransaction(pairName, ContractEnum.AUCTION, 'cancelOrder', [hash], 'WAVES', 0);\n        break;\n\n      case OrderTypeEnum.LIQUIDATE:\n        await this.keeper.sendTransaction(pairName, ContractEnum.LIQUIDATION, 'cancelOrder', [hash], 'WAVES', 0);\n        break;\n    }\n  } //RPD\n\n\n  async lockNeutrino(pairName, paymentCurrency, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.RPD, 'lockNeutrino', [], this.assets[paymentCurrency], amount);\n  }\n\n  async unlockNeutrino(pairName, paymentCurrency, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.RPD, 'unlockNeutrino', [amount, this.assets[paymentCurrency]], 'WAVES', 0);\n  }\n\n  async checkWithdraw(pairName, index, historyIndex) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.RPD, 'withdraw', [index, historyIndex], 'WAVES', 0);\n  }\n\n  async transferFunds(pairName, paymentCurrency, address, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'transfer', [address], this.assets[paymentCurrency], amount);\n  }\n\n}","map":{"version":3,"sources":["/usr/local/var/www/neutrino-web/src/components/DalComponent.js"],"names":["_get","_isEqual","setUser","apiHoc","clientStorage","BalanceController","Keeper","axios","ContractEnum","UserRole","OrderTypeEnum","STORAGE_AUTH_KEY","DalComponent","constructor","network","nodeUrl","assets","contracts","hoc","balance","dalRef","onUpdate","login","bind","keeper","process","env","NODE_ENV","window","dal","account","getAccount","start","address","user","role","REGISTERED","balances","getBalances","isLogged","set","store","require","storeUser","getState","auth","dispatch","get","logout","remove","stop","swapWavesToNeutrino","pairName","amount","sendTransaction","NEUTRINO","swapNeutrinoToWaves","paymentCurrency","withdraw","index","setBondOrder","price","bondsAmount","Math","round","contractPrice","position","params","AUCTION","setLiquidateOrder","total","LIQUIDATION","cancelOrder","type","hash","BUY","LIQUIDATE","lockNeutrino","RPD","unlockNeutrino","checkWithdraw","historyIndex","transferFunds"],"mappings":"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","sourcesContent":["import _get from 'lodash/get';\nimport _isEqual from 'lodash/isEqual';\nimport { setUser } from 'yii-steroids/actions/auth';\nimport apiHoc from './dal/apiHoc';\nimport { clientStorage } from 'components';\n\nimport BalanceController from '../contractControllers/BalanceController';\nimport Keeper from './dal/Keeper';\nimport axios from 'axios';\nimport ContractEnum from '../enums/ContractEnum';\nimport UserRole from 'enums/UserRole';\nimport OrderTypeEnum from 'enums/OrderTypeEnum';\n\nexport const STORAGE_AUTH_KEY = 'isAuth';\n\nexport default class DalComponent {\n    constructor() {\n        this.network = null;\n        this.nodeUrl = null;\n        this.assets = null;\n        this.contracts = null;\n        this.hoc = apiHoc;\n        this.balance = new BalanceController({ dalRef: this });\n        this.balance.onUpdate = this.login.bind(this);\n\n        this.keeper = new Keeper(this);\n        this.keeper.onUpdate = this.login.bind(this);\n\n        if (typeof window !== 'undefined' && process.env.NODE_ENV !== 'production') {\n            window.dal = this;\n        }\n    }\n\n    /**\n     * Auth current user and return it data\n     * @returns {Promise}\n     */\n    async login() {\n        // Start keeper listener, fetch balances\n        const account = await this.keeper.getAccount();\n        await this.keeper.start();\n        await this.balance.start(account.address);\n\n        // Keeper user\n        const user = account\n            ? {\n                role: UserRole.REGISTERED,\n                address: account.address,\n                network: account.network,\n                balances: this.balance.getBalances()\n            }\n            : null;\n\n        // Mark logged\n        if (account && !this.isLogged()) {\n            clientStorage.set(STORAGE_AUTH_KEY, '1');\n        }\n\n        // Update redux store\n        const store = require('components').store;\n        const storeUser = store.getState().auth.user || null;\n        if (!_isEqual(storeUser, user)) {\n            store.dispatch(setUser(user));\n        }\n\n        return user;\n    }\n\n    /**\n     * Check is logged flag\n     * @returns {boolean}\n     */\n    isLogged() {\n        return clientStorage.get(STORAGE_AUTH_KEY) === '1';\n    }\n\n    /**\n     * Logout user\n     * @returns {Promise<void>}\n     */\n    async logout() {\n        require('components').store.dispatch(setUser(null));\n        clientStorage.remove(STORAGE_AUTH_KEY);\n\n        this.keeper.stop();\n        this.balance.stop();\n    }\n\n    async swapWavesToNeutrino(pairName, amount) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.NEUTRINO,\n            'swapWavesToNeutrino',\n            [],\n            'WAVES',\n            amount\n        );\n    }\n\n    async swapNeutrinoToWaves(pairName, paymentCurrency, amount) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.NEUTRINO,\n            'swapNeutrinoToWaves',\n            [],\n            this.assets[paymentCurrency],\n            amount\n        );\n    }\n\n    async withdraw(pairName, address, index) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.NEUTRINO,\n            'withdraw',\n            [address, index],\n            'WAVES',\n            0\n        );\n    }\n\n    async setBondOrder(pairName, price, paymentCurrency, bondsAmount) {\n        if (price <= 0 || price >= 1) {\n            return;\n        }\n        price = Math.round(price * 100) / 100;\n        const contractPrice = price * 100;\n        let position = _get(\n            await axios.get(`/api/v1/bonds/${pairName}/position`, {\n                params: { price: contractPrice }\n            }),\n            'data.position'\n        );\n\n        if (price > 0 && bondsAmount > 0 && Number.isInteger(position)) {\n            await this.keeper.sendTransaction(\n                pairName,\n                ContractEnum.AUCTION,\n                'addBuyBondOrder',\n                [contractPrice, position],\n                this.assets[paymentCurrency],\n                bondsAmount * price\n            );\n        }\n    }\n    async setLiquidateOrder(pairName, paymentCurrency, total) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.LIQUIDATION,\n            'addLiquidationOrder',\n            [],\n            this.assets[paymentCurrency],\n            total\n        );\n    }\n\n    async cancelOrder(pairName, type, hash) {\n        switch (type) {\n            case OrderTypeEnum.BUY:\n                await this.keeper.sendTransaction(\n                    pairName,\n                    ContractEnum.AUCTION,\n                    'cancelOrder',\n                    [hash],\n                    'WAVES',\n                    0\n                );\n                break;\n\n            case OrderTypeEnum.LIQUIDATE:\n                await this.keeper.sendTransaction(\n                    pairName,\n                    ContractEnum.LIQUIDATION,\n                    'cancelOrder',\n                    [hash],\n                    'WAVES',\n                    0\n                );\n                break;\n        }\n    }\n\n    //RPD\n    async lockNeutrino(pairName, paymentCurrency, amount) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.RPD,\n            'lockNeutrino',\n            [],\n            this.assets[paymentCurrency],\n            amount\n        );\n    }\n\n    async unlockNeutrino(pairName, paymentCurrency, amount) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.RPD,\n            'unlockNeutrino',\n            [amount, this.assets[paymentCurrency]],\n            'WAVES',\n            0\n        );\n    }\n\n    async checkWithdraw(pairName, index, historyIndex) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.RPD,\n            'withdraw',\n            [index, historyIndex],\n            'WAVES',\n            0\n        );\n    }\n\n    async transferFunds(pairName, paymentCurrency, address, amount) {\n        await this.keeper.sendTransaction(\n            pairName,\n            ContractEnum.NEUTRINO,\n            'transfer',\n            [\n                address\n            ],\n            this.assets[paymentCurrency],\n            amount,\n        );\n    }\n\n}\n"]},"metadata":{},"sourceType":"module"}