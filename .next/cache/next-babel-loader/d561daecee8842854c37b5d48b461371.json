{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport _trimStart from 'lodash-es/trimStart';\nimport _trimEnd from 'lodash-es/trimEnd';\nimport { setFlashes } from '../actions/notifications';\nimport axios from 'axios';\nimport _isFunction from 'lodash-es/isFunction';\nimport _isObject from 'lodash-es/isObject';\nexport default class HttpComponent {\n  constructor() {\n    this.apiUrl = location.protocol + '//' + location.host;\n    this.accessTokenKey = 'accessToken';\n    this._lazyRequests = {};\n    this._axios = null;\n    this._csrfToken = null;\n    this._accessToken = false;\n  }\n\n  getAxiosConfig() {\n    const config = {\n      withCredentials: true,\n      headers: {\n        // Add XMLHttpRequest header for detect ajax requests\n        'X-Requested-With': 'XMLHttpRequest',\n        // Add Content-Type\n        'Content-Type': 'application/json'\n      }\n    }; // Add CSRF header\n\n    if (!this._csrfToken && !process.env.IS_NODE) {\n      const metaElement = document.querySelector('meta[name=csrf-token]');\n\n      if (metaElement) {\n        this._csrfToken = metaElement.getAttribute('content');\n      }\n    }\n\n    if (this._csrfToken) {\n      config.headers['X-CSRF-Token'] = this._csrfToken;\n    } // Set access token\n\n\n    const clientStorage = require('components').clientStorage;\n\n    if (this._accessToken === false) {\n      this._accessToken = clientStorage.get(this.accessTokenKey) || null;\n    }\n\n    if (this._accessToken) {\n      config.headers['Authorization'] = 'Bearer ' + this._accessToken;\n    }\n\n    return config;\n  }\n  /**\n   * @param value\n   */\n\n\n  setCsrfToken(value) {\n    this._csrfToken = value;\n    this.resetConfig();\n  }\n  /**\n   * @param value\n   */\n\n\n  setAccessToken(value) {\n    this._accessToken = value;\n    this.resetConfig();\n\n    const clientStorage = require('components').clientStorage;\n\n    clientStorage.set(this.accessTokenKey, value);\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  getAccessToken() {\n    if (this._accessToken === false) {\n      const clientStorage = require('components').clientStorage;\n\n      this._accessToken = clientStorage.get(this.accessTokenKey) || null;\n    }\n\n    return this._accessToken;\n  }\n\n  resetConfig() {\n    this._axios = null;\n  }\n\n  getAxiosInstance() {\n    if (!this._axios) {\n      this._axios = axios.create(this.getAxiosConfig());\n    }\n\n    return this._axios;\n  }\n\n  getUrl(method) {\n    if (method === null) {\n      method = location.pathname;\n    }\n\n    if (method.indexOf('://') === -1) {\n      method = `${_trimEnd(this.apiUrl, '/')}/${_trimStart(method, '/')}`;\n    }\n\n    return method;\n  }\n\n  get(url, params = {}, options = {}) {\n    return this._send(url, {\n      method: 'get',\n      params: params\n    }, options).then(response => response.data);\n  }\n\n  post(url, params = {}, options = {}) {\n    return this._send(url, {\n      method: 'post',\n      data: params\n    }, options).then(response => response.data);\n  }\n\n  delete(url, params = {}, options = {}) {\n    return this._send(url, {\n      method: 'delete',\n      data: params\n    }, options).then(response => response.data);\n  }\n\n  send(method, url, params = {}, options = {}) {\n    method = method.toLowerCase();\n    return this._send(url, {\n      method,\n      [method === 'get' ? 'params' : 'data']: params\n    }, options, true);\n  }\n\n  hoc(requestFunc) {\n    return WrappedComponent => {\n      var _class, _temp;\n\n      return _temp = _class = class HttpHOC extends React.Component {\n        constructor() {\n          super(...arguments);\n          this.state = {\n            data: null\n          };\n          this._isRendered = false;\n          this._cancels = [];\n          this._fetch = this._fetch.bind(this);\n          this._createCancelToken = this._createCancelToken.bind(this);\n        }\n\n        componentDidMount() {\n          this._isRendered = true;\n\n          this._fetch();\n        }\n\n        componentWillUnmount() {\n          this._isRendered = false;\n\n          this._cancels.forEach(cancel => cancel('Canceled on unmount component'));\n        }\n\n        render() {\n          return __jsx(WrappedComponent, _extends({}, this.props, this.state.data, {\n            fetch: this._fetch\n          }));\n        }\n\n        _createCancelToken() {\n          return new axios.CancelToken(cancel => {\n            this._cancels.push(cancel);\n          });\n        }\n\n        _fetch(params) {\n          const result = requestFunc(_objectSpread({}, this.props, {}, params, {\n            createCancelToken: this._createCancelToken\n          }));\n\n          if (_isObject(result)) {\n            if (_isFunction(result.then)) {\n              return result.then(data => {\n                if (this._isRendered) {\n                  this.setState({\n                    data\n                  });\n                }\n\n                return data;\n              });\n            } else {\n              this.setState({\n                data: result\n              });\n            }\n          }\n\n          return result;\n        }\n\n      }, _defineProperty(_class, \"WrappedComponent\", WrappedComponent), _temp;\n    };\n  }\n\n  _send(method, config, options) {\n    const axiosConfig = _objectSpread({}, config, {\n      url: this.getUrl(method)\n    });\n\n    if (options.cancelToken) {\n      axiosConfig.cancelToken = options.cancelToken;\n    }\n\n    if (options.lazy) {\n      if (this._lazyRequests[method]) {\n        clearTimeout(this._lazyRequests[method]);\n      }\n\n      return new _Promise((resolve, reject) => {\n        const timeout = options.lazy !== true ? options.lazy : 200;\n        this._lazyRequests[method] = setTimeout(() => {\n          this._sendAxios(axiosConfig).then(result => resolve(result)).catch(result => reject(result));\n        }, timeout);\n      });\n    }\n\n    return this._sendAxios(axiosConfig);\n  }\n\n  _sendAxios(config) {\n    return this.getAxiosInstance()(config).then(response => {\n      this.afterRequest(response);\n      return response;\n    });\n  }\n\n  afterRequest(response) {\n    const store = require('components').store; // Flash\n\n\n    if (response.data.flashes) {\n      store.dispatch(setFlashes(response.data.flashes));\n    } // Ajax redirect\n\n\n    if (response.data.redirectUrl) {\n      if (location.href === response.data.redirectUrl.split('#')[0]) {\n        window.location.href = response.data.redirectUrl;\n        window.location.reload();\n      } else {\n        window.location.href = response.data.redirectUrl;\n      }\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}