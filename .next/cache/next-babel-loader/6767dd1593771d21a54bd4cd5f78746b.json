{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport _trimStart from 'lodash-es/trimStart';\nimport _trimEnd from 'lodash-es/trimEnd';\nimport { setFlashes } from '../actions/notifications';\nimport axios from 'axios';\nimport _isFunction from 'lodash-es/isFunction';\nimport _isObject from 'lodash-es/isObject';\n\nvar HttpComponent =\n/*#__PURE__*/\nfunction () {\n  function HttpComponent() {\n    _classCallCheck(this, HttpComponent);\n\n    this.apiUrl = location.protocol + '//' + location.host;\n    this.accessTokenKey = 'accessToken';\n    this._lazyRequests = {};\n    this._axios = null;\n    this._csrfToken = null;\n    this._accessToken = false;\n  }\n\n  _createClass(HttpComponent, [{\n    key: \"getAxiosConfig\",\n    value: function getAxiosConfig() {\n      var config = {\n        withCredentials: true,\n        headers: {\n          // Add XMLHttpRequest header for detect ajax requests\n          'X-Requested-With': 'XMLHttpRequest',\n          // Add Content-Type\n          'Content-Type': 'application/json'\n        }\n      }; // Add CSRF header\n\n      if (!this._csrfToken && !process.env.IS_NODE) {\n        var metaElement = document.querySelector('meta[name=csrf-token]');\n\n        if (metaElement) {\n          this._csrfToken = metaElement.getAttribute('content');\n        }\n      }\n\n      if (this._csrfToken) {\n        config.headers['X-CSRF-Token'] = this._csrfToken;\n      } // Set access token\n\n\n      var clientStorage = require('components').clientStorage;\n\n      if (this._accessToken === false) {\n        this._accessToken = clientStorage.get(this.accessTokenKey) || null;\n      }\n\n      if (this._accessToken) {\n        config.headers['Authorization'] = 'Bearer ' + this._accessToken;\n      }\n\n      return config;\n    }\n    /**\n     * @param value\n     */\n\n  }, {\n    key: \"setCsrfToken\",\n    value: function setCsrfToken(value) {\n      this._csrfToken = value;\n      this.resetConfig();\n    }\n    /**\n     * @param value\n     */\n\n  }, {\n    key: \"setAccessToken\",\n    value: function setAccessToken(value) {\n      this._accessToken = value;\n      this.resetConfig();\n\n      var clientStorage = require('components').clientStorage;\n\n      clientStorage.set(this.accessTokenKey, value);\n    }\n    /**\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getAccessToken\",\n    value: function getAccessToken() {\n      if (this._accessToken === false) {\n        var clientStorage = require('components').clientStorage;\n\n        this._accessToken = clientStorage.get(this.accessTokenKey) || null;\n      }\n\n      return this._accessToken;\n    }\n  }, {\n    key: \"resetConfig\",\n    value: function resetConfig() {\n      this._axios = null;\n    }\n  }, {\n    key: \"getAxiosInstance\",\n    value: function getAxiosInstance() {\n      if (!this._axios) {\n        this._axios = axios.create(this.getAxiosConfig());\n      }\n\n      return this._axios;\n    }\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(method) {\n      if (method === null) {\n        method = location.pathname;\n      }\n\n      if (method.indexOf('://') === -1) {\n        method = \"\".concat(_trimEnd(this.apiUrl, '/'), \"/\").concat(_trimStart(method, '/'));\n      }\n\n      return method;\n    }\n  }, {\n    key: \"get\",\n    value: function get(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._send(url, {\n        method: 'get',\n        params: params\n      }, options).then(function (response) {\n        return response.data;\n      });\n    }\n  }, {\n    key: \"post\",\n    value: function post(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._send(url, {\n        method: 'post',\n        data: params\n      }, options).then(function (response) {\n        return response.data;\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(url) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._send(url, {\n        method: 'delete',\n        data: params\n      }, options).then(function (response) {\n        return response.data;\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(method, url) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      method = method.toLowerCase();\n      return this._send(url, _defineProperty({\n        method: method\n      }, method === 'get' ? 'params' : 'data', params), options, true);\n    }\n  }, {\n    key: \"hoc\",\n    value: function hoc(requestFunc) {\n      return function (WrappedComponent) {\n        var _class, _temp;\n\n        return _temp = _class =\n        /*#__PURE__*/\n        function (_React$Component) {\n          _inherits(HttpHOC, _React$Component);\n\n          function HttpHOC() {\n            var _this;\n\n            _classCallCheck(this, HttpHOC);\n\n            _this = _possibleConstructorReturn(this, _getPrototypeOf(HttpHOC).apply(this, arguments));\n            _this.state = {\n              data: null\n            };\n            _this._isRendered = false;\n            _this._cancels = [];\n            _this._fetch = _this._fetch.bind(_assertThisInitialized(_this));\n            _this._createCancelToken = _this._createCancelToken.bind(_assertThisInitialized(_this));\n            return _this;\n          }\n\n          _createClass(HttpHOC, [{\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n              this._isRendered = true;\n\n              this._fetch();\n            }\n          }, {\n            key: \"componentWillUnmount\",\n            value: function componentWillUnmount() {\n              this._isRendered = false;\n\n              this._cancels.forEach(function (cancel) {\n                return cancel('Canceled on unmount component');\n              });\n            }\n          }, {\n            key: \"render\",\n            value: function render() {\n              return __jsx(WrappedComponent, _extends({}, this.props, this.state.data, {\n                fetch: this._fetch\n              }));\n            }\n          }, {\n            key: \"_createCancelToken\",\n            value: function _createCancelToken() {\n              var _this2 = this;\n\n              return new axios.CancelToken(function (cancel) {\n                _this2._cancels.push(cancel);\n              });\n            }\n          }, {\n            key: \"_fetch\",\n            value: function _fetch(params) {\n              var _this3 = this;\n\n              var result = requestFunc(_objectSpread({}, this.props, {}, params, {\n                createCancelToken: this._createCancelToken\n              }));\n\n              if (_isObject(result)) {\n                if (_isFunction(result.then)) {\n                  return result.then(function (data) {\n                    if (_this3._isRendered) {\n                      _this3.setState({\n                        data: data\n                      });\n                    }\n\n                    return data;\n                  });\n                } else {\n                  this.setState({\n                    data: result\n                  });\n                }\n              }\n\n              return result;\n            }\n          }]);\n\n          return HttpHOC;\n        }(React.Component), _defineProperty(_class, \"WrappedComponent\", WrappedComponent), _temp;\n      };\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(method, config, options) {\n      var _this4 = this;\n\n      var axiosConfig = _objectSpread({}, config, {\n        url: this.getUrl(method)\n      });\n\n      if (options.cancelToken) {\n        axiosConfig.cancelToken = options.cancelToken;\n      }\n\n      if (options.lazy) {\n        if (this._lazyRequests[method]) {\n          clearTimeout(this._lazyRequests[method]);\n        }\n\n        return new _Promise(function (resolve, reject) {\n          var timeout = options.lazy !== true ? options.lazy : 200;\n          _this4._lazyRequests[method] = setTimeout(function () {\n            _this4._sendAxios(axiosConfig).then(function (result) {\n              return resolve(result);\n            })[\"catch\"](function (result) {\n              return reject(result);\n            });\n          }, timeout);\n        });\n      }\n\n      return this._sendAxios(axiosConfig);\n    }\n  }, {\n    key: \"_sendAxios\",\n    value: function _sendAxios(config) {\n      var _this5 = this;\n\n      return this.getAxiosInstance()(config).then(function (response) {\n        _this5.afterRequest(response);\n\n        return response;\n      });\n    }\n  }, {\n    key: \"afterRequest\",\n    value: function afterRequest(response) {\n      var store = require('components').store; // Flash\n\n\n      if (response.data.flashes) {\n        store.dispatch(setFlashes(response.data.flashes));\n      } // Ajax redirect\n\n\n      if (response.data.redirectUrl) {\n        if (location.href === response.data.redirectUrl.split('#')[0]) {\n          window.location.href = response.data.redirectUrl;\n          window.location.reload();\n        } else {\n          window.location.href = response.data.redirectUrl;\n        }\n      }\n    }\n  }]);\n\n  return HttpComponent;\n}();\n\nexport { HttpComponent as default };","map":null,"metadata":{},"sourceType":"module"}