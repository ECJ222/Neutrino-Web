{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nvar __jsx = React.createElement;\nimport React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport _moment from 'moment';\nimport _isObject from 'lodash-es/isObject';\nimport 'moment/locale/it';\nimport 'moment/locale/ru'; // Fix load locale data\n\nwindow.IntlMessageFormat = IntlMessageFormat;\n\nrequire('intl-messageformat/dist/locale-data/ru');\n\ndelete window.IntlMessageFormat;\n/**\n * @example\n *  {__('{count} {count, plural, one{день} few{дня} many{дней}}', {count: 2})}\n */\n\nvar LocaleComponent =\n/*#__PURE__*/\nfunction () {\n  function LocaleComponent() {\n    _classCallCheck(this, LocaleComponent);\n\n    this.language = 'en';\n    this.sourceLanguage = 'ru';\n    this.backendTimeZone = null;\n    this.backendTimeDiff = null; // in microseconds\n\n    this.translations = {}; // Publish to global\n\n    if (process.env.IS_NODE) {\n      global.__ = this.translate.bind(this);\n    } else {\n      window.__ = this.translate.bind(this);\n    }\n  }\n\n  _createClass(LocaleComponent, [{\n    key: \"moment\",\n    value: function moment(date, format) {\n      if (this.backendTimeZone && date && date.length === 19 && _moment(date, 'YYYY-MM-DD HH:mm:ss').isValid()) {\n        date = date + this.backendTimeZone;\n      }\n\n      return _moment(date, format).locale(this.language);\n    }\n  }, {\n    key: \"t\",\n    value: function t(message) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.translate(message, params);\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(message) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Translate\n      var hasTranslate = !!this.translations[message];\n      message = this.translations[message] || message; // Cut react components\n\n      var components = {};\n\n      _Object$keys(params).map(function (key) {\n        if (_isObject(params[key])) {\n          components[key] = params[key];\n          params[key] = \"!!\".concat(key, \"!!\");\n        }\n      }); // Format message (params, plural, etc..)\n\n\n      var language = hasTranslate ? this.language : this.sourceLanguage;\n      var formatter = new IntlMessageFormat(message, language);\n      message = formatter.format(params); // Paste react components\n\n      message = this._pasteComponents(message, components);\n      return message;\n    }\n  }, {\n    key: \"_pasteComponents\",\n    value: function _pasteComponents(message, components) {\n      if (_Object$keys(components).length === 0) {\n        return message;\n      } // Index components\n\n\n      var indexedComponents = [];\n\n      _Object$keys(components).map(function (key) {\n        var index = message.indexOf(\"!!\".concat(key, \"!!\"));\n\n        if (index !== -1) {\n          indexedComponents.push({\n            index: index,\n            component: components[key]\n          });\n        }\n\n        message = message.replace(\"!!\".concat(key, \"!!\"), '!!component!!');\n      });\n\n      indexedComponents.sort(function (a, b) {\n        if (a.index < b.index) {\n          return -1;\n        } else if (a.index > b.index) {\n          return 1;\n        }\n\n        return 0;\n      }); // Split text to array, paste components\n\n      var result = [];\n      var textParts = message.split('!!component!!');\n\n      for (var i = 0, j = 0; i < textParts.length; i++) {\n        var isComponentAdded = false;\n\n        if (j === 0 && j < indexedComponents.length && indexedComponents[j].index === 0) {\n          result.push(__jsx(\"span\", {\n            key: \"element-\".concat(j)\n          }, indexedComponents[j].component));\n          isComponentAdded = true;\n          j++;\n        }\n\n        result.push(__jsx(\"span\", {\n          key: \"text-\".concat(i)\n        }, textParts[i]));\n\n        if (!isComponentAdded && j < indexedComponents.length) {\n          result.push(__jsx(\"span\", {\n            key: \"element\".concat(j)\n          }, indexedComponents[j].component));\n          j++;\n        }\n      }\n\n      return __jsx(\"span\", null, result);\n    }\n  }]);\n\n  return LocaleComponent;\n}();\n\nexport { LocaleComponent as default };","map":null,"metadata":{},"sourceType":"module"}