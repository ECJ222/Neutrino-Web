{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport _get from 'lodash-es/get';\nimport _isMatch from 'lodash-es/isMatch';\nimport _every from 'lodash-es/every';\nimport _extend from 'lodash-es/extend';\nimport { LIST_INIT, LIST_BEFORE_FETCH, LIST_AFTER_FETCH, LIST_ITEM_ADD, LIST_ITEM_UPDATE, LIST_DESTROY, LIST_TOGGLE_ITEM, LIST_TOGGLE_ALL, LIST_SET_LAYOUT } from '../actions/list';\nconst initialState = {\n  lists: {},\n  selectedIds: {}\n};\nexport default ((state = initialState, action) => {\n  switch (action.type) {\n    case LIST_INIT:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({\n            meta: {},\n            layoutName: null,\n            total: action.total || (action.items ? action.items.length : 0),\n            isFetched: !!action.items,\n            isLoading: false\n          }, action)\n        })\n      });\n\n    case LIST_BEFORE_FETCH:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, state.lists[action.listId], {}, action, {\n            isLoading: true\n          })\n        })\n      });\n\n    case LIST_AFTER_FETCH:\n      let items;\n      const list = state.lists[action.listId];\n\n      if (list && list.items && list.loadMore && list.page > 1) {\n        items = [].concat(list.items);\n        action.items.forEach((entry, i) => {\n          const index = (list.page - 1) * list.pageSize + i;\n          items[index] = entry;\n        });\n      } else {\n        items = [].concat(action.items);\n      }\n\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, list, {}, action, {\n            items,\n            isFetched: true,\n            isLoading: false\n          })\n        })\n      });\n\n    case LIST_ITEM_ADD:\n      if (state.lists[action.listId]) {\n        return _objectSpread({}, state, {\n          lists: _objectSpread({}, state.lists, {\n            [action.listId]: _objectSpread({}, state.lists[action.listId], {\n              items: action.prepend ? [].concat(action.item).concat(state.lists[action.listId].items) : [].concat(state.lists[action.listId].items).concat(action.item)\n            })\n          })\n        });\n      }\n\n      break;\n\n    case LIST_ITEM_UPDATE:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, state.lists[action.listId], {\n            items: state.lists[action.listId].items.map(item => {\n              if (_isMatch(item, action.condition)) {\n                item = _extend({}, item, action.item);\n              }\n\n              return item;\n            })\n          })\n        })\n      });\n\n    case LIST_DESTROY:\n      delete state.lists[action.listId];\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists)\n      });\n\n    case LIST_TOGGLE_ITEM:\n      const selectedIds = _get(state, ['selectedIds', action.listId]) || [];\n      const index = selectedIds.indexOf(action.itemId);\n\n      if (index === -1) {\n        selectedIds.push(action.itemId);\n      } else {\n        selectedIds.splice(index, 1);\n      }\n\n      return _objectSpread({}, state, {\n        selectedIds: _objectSpread({}, state.selectedIds, {\n          [action.listId]: [].concat(selectedIds)\n        })\n      });\n\n    case LIST_TOGGLE_ALL:\n      const list4 = state.lists[action.listId];\n\n      if (list4) {\n        const ids = list4.items.map(item => item[list4.primaryKey]) || [];\n\n        const isAll = state.selectedIds[action.listId] && _every(ids.map(id => state.selectedIds[action.listId].includes(id)));\n\n        return _objectSpread({}, state, {\n          selectedIds: _objectSpread({}, state.selectedIds, {\n            [action.listId]: isAll ? [] : ids\n          })\n        });\n      }\n\n      break;\n\n    case LIST_SET_LAYOUT:\n      return _objectSpread({}, state, {\n        lists: _objectSpread({}, state.lists, {\n          [action.listId]: _objectSpread({}, state.lists[action.listId], {\n            layoutName: action.layoutName\n          })\n        })\n      });\n  }\n\n  return state;\n});\nexport const getList = (state, listId) => _get(state, ['list', 'lists', listId]) || null;\nexport const getIds = (state, listId) => {\n  const list = getList(state, listId);\n  return list && list.items && list.items.map(item => item[list.primaryKey]) || [];\n};\nexport const getCheckedIds = (state, listId) => {\n  return _get(state, ['list', 'selectedIds', listId]) || [];\n};\nexport const isChecked = (state, listId, itemId) => getCheckedIds(state, listId).includes(itemId);\nexport const isCheckedAll = (state, listId) => {\n  const selectedIds = getCheckedIds(state, listId);\n  return selectedIds.length > 0 && _every(getIds(state, listId).map(id => selectedIds.includes(id)));\n};","map":null,"metadata":{},"sourceType":"module"}