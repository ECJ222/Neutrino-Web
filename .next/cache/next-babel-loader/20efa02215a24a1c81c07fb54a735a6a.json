{"ast":null,"code":"import _Number$isInteger from \"@babel/runtime-corejs2/core-js/number/is-integer\";\nimport _get from 'lodash/get';\nimport _isEqual from 'lodash/isEqual';\nimport { setUser } from 'yii-steroids/actions/auth';\nimport apiHoc from './dal/apiHoc';\nimport { clientStorage } from 'components';\nimport BalanceController from '../contractControllers/BalanceController';\nimport Keeper from './dal/Keeper';\nimport axios from 'axios';\nimport ContractEnum from '../enums/ContractEnum';\nimport UserRole from 'enums/UserRole';\nimport OrderTypeEnum from 'enums/OrderTypeEnum';\nexport const STORAGE_AUTH_KEY = 'isAuth';\nexport default class DalComponent {\n  constructor() {\n    this.network = null;\n    this.nodeUrl = null;\n    this.assets = null;\n    this.contracts = null;\n    this.hoc = apiHoc;\n    this.balance = new BalanceController({\n      dalRef: this\n    });\n    this.balance.onUpdate = this.login.bind(this);\n    this.keeper = new Keeper(this);\n    this.keeper.onUpdate = this.login.bind(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      window.dal = this;\n    }\n  }\n  /**\n   * Auth current user and return it data\n   * @returns {Promise}\n   */\n\n\n  async login() {\n    // Start keeper listener, fetch balances\n    const account = await this.keeper.getAccount();\n    await this.keeper.start();\n    await this.balance.start(account.address); // Keeper user\n\n    const user = account ? {\n      role: UserRole.REGISTERED,\n      address: account.address,\n      network: account.network,\n      balances: this.balance.getBalances()\n    } : null; // Mark logged\n\n    if (account && !this.isLogged()) {\n      clientStorage.set(STORAGE_AUTH_KEY, '1');\n    } // Update redux store\n\n\n    const store = require('components').store;\n\n    const storeUser = store.getState().auth.user || null;\n\n    if (!_isEqual(storeUser, user)) {\n      store.dispatch(setUser(user));\n    }\n\n    return user;\n  }\n  /**\n   * Check is logged flag\n   * @returns {boolean}\n   */\n\n\n  isLogged() {\n    return clientStorage.get(STORAGE_AUTH_KEY) === '1';\n  }\n  /**\n   * Logout user\n   * @returns {Promise<void>}\n   */\n\n\n  async logout() {\n    require('components').store.dispatch(setUser(null));\n\n    clientStorage.remove(STORAGE_AUTH_KEY);\n    this.keeper.stop();\n    this.balance.stop();\n  }\n\n  async swapWavesToNeutrino(pairName, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'swapWavesToNeutrino', [], 'WAVES', amount);\n  }\n\n  async swapNeutrinoToWaves(pairName, paymentCurrency, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'swapNeutrinoToWaves', [], this.assets[paymentCurrency], amount);\n  }\n\n  async withdraw(pairName, address, index) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.NEUTRINO, 'withdraw', [address, index], 'WAVES', 0);\n  }\n\n  async setBondOrder(pairName, price, paymentCurrency, bondsAmount) {\n    if (price <= 0 || price >= 1) {\n      return;\n    }\n\n    price = Math.round(price * 100) / 100;\n    const contractPrice = price * 100;\n\n    let position = _get((await axios.get(`/api/v1/bonds/${pairName}/position`, {\n      params: {\n        price: contractPrice\n      }\n    })), 'data.position');\n\n    if (price > 0 && bondsAmount > 0 && _Number$isInteger(position)) {\n      await this.keeper.sendTransaction(pairName, ContractEnum.AUCTION, 'addBuyBondOrder', [contractPrice, position], this.assets[paymentCurrency], bondsAmount * price);\n    }\n  }\n\n  async setLiquidateOrder(pairName, paymentCurrency, total) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.LIQUIDATION, 'addLiquidationOrder', [], this.assets[paymentCurrency], total);\n  }\n\n  async cancelOrder(pairName, type, hash) {\n    switch (type) {\n      case OrderTypeEnum.BUY:\n        await this.keeper.sendTransaction(pairName, ContractEnum.AUCTION, 'cancelOrder', [hash], 'WAVES', 0);\n        break;\n\n      case OrderTypeEnum.LIQUIDATE:\n        await this.keeper.sendTransaction(pairName, ContractEnum.LIQUIDATION, 'cancelOrder', [hash], 'WAVES', 0);\n        break;\n    }\n  } //RPD\n\n\n  async lockNeutrino(pairName, paymentCurrency, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.RPD, 'lockNeutrino', [], this.assets[paymentCurrency], amount);\n  }\n\n  async unlockNeutrino(pairName, paymentCurrency, amount) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.RPD, 'unlockNeutrino', [amount, this.assets[paymentCurrency]], 'WAVES', 0);\n  }\n\n  async checkWithdraw(pairName, index, historyIndex) {\n    await this.keeper.sendTransaction(pairName, ContractEnum.RPD, 'withdraw', [index, historyIndex], 'WAVES', 0);\n  }\n\n  async transferFunds(pairName, paymentCurrency, address, amount) {\n    await this.keeper.transfer(pairName, address, amount, this.assets[paymentCurrency] || 'WAVES');\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}